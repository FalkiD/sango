// WARNING!! DO NOT EDIT THIS FILE (automatically generated)
// File created Fri Oct 11 15:55:10 2013 by make_registers v15
//
// (C) Copyright 2008, Qux Corporation
//     All rights reserved.
//
//		       PROPRIETARY INFORMATION
//
// The information contained in this file is the property of Qux Corporation
// Except as specifically authorized in writing by Qux, the holder of this file
// shall keep all information contained herein confidential and shall protect
// same in whole or in part from disclosure and dissemination to all third
// parties and shall use same for operation and maintenance purposes only.

`include "registers_def.v"

`include "timescale.v"

module registers (clk_i, rst_i, adr_i, dat_i, we_i, stb_i, dat_o, ack_o, reg_w, reg_r, reg_ctl);

   // external interface ports
   input		clk_i, rst_i, we_i, stb_i;
   input [6:0]		adr_i;
   input [15:0]		dat_i;
   output		ack_o;
   output [15:0]	dat_o;

   // generated interface ports
   input [`REG_BITS_R]     reg_r;
   output [`REG_BITS_W]    reg_w;
   output [`REG_BITS_CTL]  reg_ctl;

   // declarations
   wire			wr_keep;
   assign		wr_keep = stb_i & we_i;

   wire			rd_keep;
   assign		rd_keep = stb_i & ~we_i;

   wire [6:0]		address_keep;
   assign		address_keep = adr_i;

   reg [15:0]		dat_i_dly1 = 0;
   reg [15:0]		dat_i_dly = 0;
   reg [15:0]		dat_o_r_rw = 0;
   reg [6:0]		address_dly1 = 0;
   reg			wr_dly1 = 0;
   reg			rd_dly1 = 0;
   reg			rd_ack = 0;
   wire	    		wr_strobe, ctl_clk, reg_r_decode;

   assign 		ack_o = wr_keep | rd_ack; // 0 WS for (RW, W) writes, 1 WS for internal (RW) reads, 2 WS for external (R) reads
   assign		ctl_clk = 1'b0;

   // generated declarations for RW registers, strobes

   // generated declarations for W strobes

   // generated declarations for R strobes
   reg			version_rd = 0;

   assign		reg_w = {
				dat_i_dly
			};

   assign		reg_ctl = {
				version_rd,
				ctl_clk
				};

   always @ (posedge clk_i)			// input address and control pipeline
      if (rst_i) begin
         address_dly1 <= 0;
         wr_dly1 <= 0;
         rd_dly1 <= 0;
         rd_ack <= 0;
      end
      else begin
         if (rd_keep | wr_keep)
            address_dly1 <= address_keep;
         wr_dly1 <= wr_keep;
         rd_dly1 <= rd_keep;
	 rd_ack <= reg_r_decode ? rd_dly1 : rd_keep;
      end

   assign wr_strobe = wr_dly1 & ~wr_keep;	// generate single-clock write strobes at end of write cycle

   always @ (posedge clk_i)			// data pipeline
      if (rst_i) begin
         dat_i_dly1 <= 0;
         dat_i_dly <= 0;			// align pipelined data with write strobes, reg_w
      end
      else begin
         dat_i_dly <= dat_i_dly1;
         if (wr_keep)
            dat_i_dly1 <= dat_i;
      end

   always @ (posedge clk_i) // R load decodes
      if (rst_i) begin
         version_rd <= 0;
      end
      else begin
         version_rd <= (address_keep == `VERSION_AD) & rd_keep & ~rd_ack;
      end
   assign reg_r_decode = rd_keep & (1'b0
					  | (address_keep == `VERSION_AD)
					  );

   always @ (posedge clk_i) // reads for RW and R registers
      if (rst_i) begin
         dat_o_r_rw <= 0;
      end
      else if (rd_keep)
            case (address_keep)
              `VERSION_AD: dat_o_r_rw <= reg_r[`VERSION_INDEX];
            endcase

   assign dat_o = dat_o_r_rw;

endmodule
