# 0.04.0  2013-10-10 (RAW) Updated with SYNC_SRC
# 0.02.0  2013-09-30 (RAW) Updated with new TG info
# 0.01.0  2013-08-19 (RAW) Initial register information
# Register name is required, case insensitive
# Hex byte address is required, must fit into specified AddrWidth
# Size is required, specified as number of bytes, must be power of 2
# Register type is required, specified as:
#   R => readback lines in reg_r, read strobe in reg_ctl
#   W => load strobe in reg_ctl
#   RW => registered, write lines in reg_w, readback lines in reg_r, read and load strobes in reg_ctl
# Hex reset value optional, may be defined for RW regs, defaults to 0, must fit into specified reg size
# Bitfields may be specified as REGISTER [start[:stop]] = BITFIELD

[registers]             # name of Verilog module to be generated
DataWidth = 16          # default is 16
AddrWidth = 7           # default is 32
ClkEnable = 0           # clock enable to allow multi-cycle timing

# Register_Name = Addr, Size, R/W, Read_Mask,   Write_Mask,  Reset_Value  # Description
# -------------   ----- ----- ---- -----------  -----------  -----------  ------------------------------------
CONF            = 0x00,   2,  RW,  0xffff,      0xffff,      0x0000       # Configuration
   CONF[15:12] = MEAS_EN        # enable Zmon measurements on specified channels
   CONF[11:8] = SRC_EN          # enable RF outputs on specified channels
   CONF[7:4] = CONT             # enable continuous retriggering on specified channels
   CONF[3:0] = TG_EN            # enable timing generators on specified channels

TRIG_SRC        = 0x02,   2,  RW,  0x7777,      0x7777,      0x0000       # Trigger sources
   TRIG_SRC[14:12] = SRC4       # channel 4: 0 = off (manual only), 1-4 = specified TRIG input, 7 = auto
   TRIG_SRC[10:8] = SRC3        # channel 3
   TRIG_SRC[6:4] = SRC2         # channel 2
   TRIG_SRC[2:0] = SRC1         # channel 1

CTRL            = 0x04,   2,   W,  0x0000,      0xcf0f                    # Timing generator control
   CTRL[15] = RST               # reset everything
   CTRL[14] = ABT               # abort bursts, clear arm
   CTRL[11:8] = TRIG            # trigger specified channels
   CTRL[3:0] = ARM              # arm specified channels for triggering

STAT            = 0x06,   2,  R,   0xffff,      0x0000,      0x0000       # Timing generator status monitor
   STAT[15:12] = STAT4          # channel 4 status: TBD
   STAT[11:8] = STAT3           # channel 3 status
   STAT[7:4] = STAT4            # channel 2 status
   STAT[3:0] = STAT1            # channel 1 status

IRQ             = 0x08,   2,  R,   0xffff,      0x0000,      0x0000       # Interrupt monitor
   IRQ[15:12] = MDONE           # enable measurement done interrupt on specified channels
   IRQ[11:8] = MHALF            # enable measurement FIFO half full interrupts
   IRQ[7:4] = SDONE             # enable SPI transfer done interrupts
   IRQ[3:0] = TDONE             # enable burst generation done interrupts

IRQ_MASK        = 0x0a,   2, RW,   0xffff,      0xffff,      0x0000       # Interrupt enable mask
   IRQ_MASK[15:12] = MDONE
   IRQ_MASK[11:8] = MHALF
   IRQ_MASK[7:4] = SDONE
   IRQ_MASK[3:0] = TDONE

IRQ_CLR         = 0x0c,   2,  W,   0x0000,      0xffff                    # Clear interrupt monitor
   IRQ_CLR[15:12] = MDONE
   IRQ_CLR[11:8] = MHALF
   IRQ_CLR[7:4] = SDONE
   IRQ_CLR[3:0] = TDONE

SYNC            = 0x0e,   2,  RW,  0xff1f,      0xff1f,      0x0000       # SYNCOUT sources
   SYNC[15:8] = GEN             # internal pulse generator period in ms, 0-4=off
   SYNC[4:0] = SRC              # 0 = MCU, 1 = GEN, 4-7 = TRIG1-4, 8-11 = TDONE1-4, 12-15 = MDONE1-4,
   	       			# 16-19 = CONV[1:4], 20-23 = GATE[1:4], 24 = SYNCIN

EXTDIG          = 0x10,   2,   R,  0x0fff,      0x0000,      0x0000       # XDIGE external digital inputs
   EXTDIG[11:0] = IN

FILTER          = 0x12,   2,  RW,  0xffff,      0xffff,      0x2710       # Trigger filter length
   FILTER[15:0] = LEN	  # trigger filter length, 100ns resolution

MUX             = 0x14,   2,  RW,  0x3333,      0x3333,      0x0000       # Channel pair multiplex control
   MUX[13:12] = PA4       # channel 4: 0 = direct, 1 = swap, 2 = direct -> swap, 3 = swap -> direct
   MUX[9:8] = PA3         # channel 3
   MUX[5:4] = PA2         # channel 2
   MUX[1:0] = PA1         # channel 1

MULTIBOOT       = 0x7c,   2,   W,  0x0000,      0x0001                    # Multiboot control
   MULTIBOOT[0] = IMAGE         # write 1 to reconfigure with image 1

VERSION         = 0x7e,   2,   R,  0xffff,      0x0000,      0x0001       # FPGA version
   VERSION[15:12] = MAJOR_VERSION
   VERSION[11:4] = MINOR_VERSION
   VERSION[3:0] = REVISION

[tg_registers]
DataWidth = 16
AddrWidth = 5
ClkEnable = 0

# There are 4 sets of these registers, one for each channel, starting at 0x80, 0xa0, 0xc0, 0xe0
# Register_Name = Addr, Size, R/W, Read_Mask,   Write_Mask,  Reset_Value  # Description
# -------------   ---- ----- ---- -----------  -----------  -----------  -------------------------------------
TCTRL           = 0x00,   2,   W,  0x0000,      0xf800                    # Time generator control
   TCTRL[15] = RST              # reset everything
   TCTRL[14] = ABT              # abort burst, clear ARM
   TCTRL[13] = CLR              # clear TQUEUE (prior to replacing entry)
   TCTRL[12] = ARM              # arm for trigger
   TCTRL[11] = TRIG             # manual trigger
   TCTRL[10] = CONV             # manual Zmon convert strobe

TQ_STAT         = 0x02,   2,   R,  0x001f,      0x0000,      0x0000       # Time generator queue status
   TQ_STAT[4:3] = TQ_COUNT      # number of complete bursts in queue
   TQ_STAT[2:0] = TQ_PARTIAL    # number of words in partial burst

TQUEUE          = 0x04,   4,  RW,  0xffffffff,  0xffffffff,  0x00000000   # Write burst parameters into queue
# write 4 32-bit words of timing parameters into TQUEUE for each burst in sequence
#   +31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0+
#   +-----------------------+-----------------------+-----------------------+-----------------------+
# 1 |||||||      POWER      |                 TC                |                 NP                |
#   +-----------------------+-----------------------+-----------------------+-----------------------+
# 2 ||||                     TO                     ||||                     TD                     |
#   +-----------------------+-----------------------+-----------------------+-----------------------+
# 3 ||||                     TF                     ||||                     TW                     |
#   +-----------------------+-----------------------+-----------------------+-----------------------+
# 4 ||||      FREQUENCY     |                 TS                |                 TK                |
#   +-----------------------+-----------------------+-----------------------+-----------------------+
# NP = number of pulses in the burst (0..4095, 0 disables burst)
# TC = number of Zmon measurements in burst (0..4095)
# POWER = VGA setting (0..63; 0.5dB steps)
# TD = starting delay for burst (0..32767; 0.1us steps)
# TO = offset into pulse for Zmon sample (0..32767; 0.1us steps)
# TW = width of each pulse in burst (0..32767; 0.1us steps)
# TF = off-time between each pulse in burst (0..32767; 0.1us steps)
# TK = starting pulse for Zmon measurements (0..4094, 0 is first pulse)
# TS = pulse skip for Zmon measurements (0..4094, 0 means sample every pulse)
# FREQUENCY = MHz offset above 2400 (0..100; 1MHz steps)

BIAS_GATE       = 0x08,   2,  RW,  0xffff,      0xffff,      0x1388       # Trigger filter length
   BIAS_GATE[15] = EN
   BIAS_GATE[14:0] = DELAY     # delay from rising edge of trigger, 1ms resolution

MCTRL           = 0x10,   2,   W,  0x0000,      0xd000,      0x0000       # Measurement system control
   MCTRL[15] = RST             # reset measurement system, clear queue
   MCTRL[14] = ABT             # abort measurements
   MCTRL[12] = ARM             # restart measurements at next trigger

MQ_STAT         = 0x12,   2,   R,  0x0fff,      0x0fff,      0x0000       # Measurement queue status
   MQ_STAT[11:0] = COUNT        # number of words in queue (4 words per Zmon measurement)

MCONF           = 0x14,   2,  RW,  0x07ff,      0x07ff,      0x0400       # Measurement configuration
   MCONF[10:0] = MAX_COUNT      # maximum total number of samples to acquire

MQUEUE          = 0x18,   2,   R,  0xffff,      0x0000,      0x0000       # Read measurements from queue
# read 4 16-bit words from MQUEUE for each Zmon measurement
# words are signed 16-bit values in order Va(real), Va(imag), Vb(real), Vb(imag)
# Va is usually forward, Vb reflected, but it depends upon how the Zmon module is installed in the system

DEBUG           = 0x1e,   2,  RW,  0xffff,      0xffff,      0x0000       # Set debug values
# 16'h202e = force CW mode for testing (unicode RLO ;-)
